struct True
struct False

type Bool = True | False

struct None
struct Some[P]
  value: P

function[P] if (condition: True) (thenBranch: ^P) : Option[P] = Some thenBranch
function[P] if (condition: False) (thenBranch: ^P) : Option[P] = None

function not (b: True) : False = False
function not (b: False) : True = True

function[P] (lhs: Some[P]) else (value: ^P) : P = lhs.value
function[P] (lhs: None) else (value: ^P) : P = value

function[T] abort : T = abort

function (i: Int) toString : String = abort

struct EmptyList
struct ListNode[T]
  value: T
  next: List[T]
type List[T] = EmptyList | ListNode[T]

function (l : EmptyList) isEmpty : Bool = True
function[T] (l: ListNode[T]) isEmpty : Bool = False

function[T] test (l : List[T]): None =
  if (l isEmpty)
    True
  else
    False

# Primitive for applying a function object.
function[P,Q] (f: Fun[P,Q]) @ (x: P) : Q = abort

# Define map to be infix to make language nicer
function[P, Q] (l: List[P]) map (f: Fun[P, Q]) : List[Q] = 
  function inner (l: EmptyList) : List[Q] = EmptyList
  function inner (l: ListNode[P]) : List[Q] = 
    ListNode (f @ l.value) (inner l.next)
  inner l

# Example of chained use of map.
function[P,Q,R] test (l: List[P]) (f: Fun[P, Q]) (g: Fun[Q, R]) : List[R] =
  l map f map g